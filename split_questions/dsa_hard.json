{
    "hard-questions": [
        {
            "difficulty": "2392",
            "title": "Kill Monsters (Easy Version)",
            "Description": "This is the easy version of the problem. Here, the values of X, K, and H_i will not exceed 500. In a video game, you are tasked with defeating monsters. The i-th monster has a health value of H_i. You start with an initial health value of X. You can defeat the i-th monster if your current health X is strictly greater than the monster's health H_i, i.e, if X > H_i. After defeating the i-th monster, your health value changes to H_i - that is, set X = H_i. Additionally, you have access to a spell that can multiply your current health by K, but you can use this spell at most once at any point during the game. Find the maximum number of monsters you can defeat if you use the spell optimally. Note: You can defeat any monster only once. Input Format The first line of input will contain a single integer T, denoting the number of test cases. Each test case consists of two lines of input. The first line of each test case contains three space-separated integers N, X, and K — the number of monsters, your initial health, and the spell's multiplier, respectively. The second line contains N space-separated integers H_1, H_2, ..., H_N, denoting the health of monsters. Output Format For each test case, output on a new line the maximum number of monsters you can defeat using the spell optimally.",
            "Examples": [
                {
                    "example1": {
                        "Input": "3\n5 3 2\n1 2 3 4 5\n1 1 4\n4\n3 3 2\n1 2 1",
                        "Output": "5\n0\n3",
                        "Explanation": "Test case 1: Initially, X=3. If we use the spell immediately, it changes to X⋅K=3⋅2=6. Then, all 5 monsters can be defeated if we do it in the order [5,4,3,2,1]. Test case 2: Even if we multiply our health by K, it's impossible to defeat the monster since X must be strictly larger than H_i. Test case 3: Consider the following sequence of operations: Since 3=X>A_2=2, defeat monster i=2. This will change X to 2. Since 2=X>A_1=1, defeat monster i=1. This will change X to 1. Now use the spell, multiplying X by K=2 and making it 2. Since 2=X>A_3=1, defeat monster i=3. This will change X to 1. All three monsters have been defeated."
                    }
                }
            ],
            "Constraints": [
                "1≤T≤10^5",
                "1≤N≤2⋅10^5",
                "1≤Hi,X≤500",
                "2≤K≤500",
                "The sum of N over all test cases won't exceed 5⋅10^5."
            ],
            "Solution": "First, let’s solve the problem if multiplication operation didn’t exist. After killing a monster with health Hi, our strength gets set to Hi. This means the next monster we kill must have a strength that strictly less than Hi. The monsters we kill must thus have a strictly decreasing sequence of strengths. The very first monster we kill must have a strength that’s less than X. So, the maximum number of monsters that can be killed, is simply the number of distinct strengths less than X. Now, let’s think about what the multiplication operation lets us do. There are two possibilities: either we multiply right at the start, or we kill a few monsters and then multiply. The first case is trivial: multiplying right at the start gives us a strength of X⋅K, after which we can kill one monster for each distinct strength that’s less than X⋅K. The second case requires a bit more thought. Suppose we multiply right after killing a monster with strength Hi, so that we’re now at a strength of K⋅Hi. Then, We can certainly kill one monster for each distinct strength < K⋅Hi. We can also kill one monster for each distinct strength that’s ≥ Hi and < X, on our initial path to reach Hi. There is one caveat however: if there’s exactly one monster with strength Y, where both Y < K⋅Hi and Hi ≤ Y < X, then it should be counted once and not twice (since we can only kill it once). So, for a fixed Hi being the last kill before multiplication, we want to know: The number of distinct elements that are < K⋅Hi. The number of distinct elements that are < X and ≥ Hi. The number of elements that appear exactly once, and are between Hi and min(X, K⋅Hi)−1. In the easy version, the constraints on K, Hi, X are fairly small (≤ 500), so you can compute these quantities by iterating over each value from 1 to 500 and checking which of the conditions it satisfies. All you need to store is the frequency of each element. TIME COMPLEXITY: O(500⋅N) per testcase.",
            "code": "for _ in range(int(input())):\n\tn, x, k = map(int, input().split())\n\th = list(map(int, input().split()))\n\tfreq = [0]*501\n\tfor y in h: freq[y] += 1\n\n\tans = 0\n\t# consider multiplying once at the start\n\tfor y in range(1, 501):\n\t\tif y < x*k and freq[y] > 0: ans += 1\n\t\n\tfor i in range(n):\n\t\t# multiply after killing h[i]\n\t\t# one copy of everything < h[i]*k\n\t\t# one copy of everything >= h[i] and < x\n\t\t# careful about stuff between h[i] and min(x, h[i]*k)\n\n\t\tct = 0\n\t\tif h[i] >= x: continue\n\t\tfor y in range(1, 501):\n\t\t\tif freq[y] == 0: continue\n\n\t\t\tif y < h[i]*k: ct += 1\n\t\t\tif y >= h[i] and y < x: ct += 1\n\t\t\tif freq[y] == 1 and y >= h[i] and y < min(x, h[i]*k): ct -= 1\n\t\tans = max(ans, ct)\n\t\n\tprint(ans)"
        },
        {
            "difficulty": "3628",
            "title": "Magician In War",
            "Description": "There is a magician fighting against N cities. City i has an army with a strength of A_i. Let K denote the city where the magician is currently at. Initially, K=1. Every second, the magician can do exactly one of the following: If K<N, move to the (K+1)-th city and hence increase K by 1; or Choose an index i≤K and set A_i to 0, hence destroying the i-th city's army. Note that this move does not change K. After the magician has made his move, every city will attack the magician, and he will take damage equal to the current sum of all the armies' strengths, that is, (A_1+A_2+…+A_N). If the magician chooses his moves optimally, find the minimum possible total damage he will take before every army is destroyed. Input Format The first line of input will contain a single integer T, denoting the number of test cases. Each test case consists of two lines of input. The first line of each test case contains N — the number of cities. The second line of each test case contains N space-separated integers A_1, A_2, …, A_N, denoting the array A. Output Format For each test case, output on a new line the minimum possible total damage the magician must take.",
            "Examples": [
                {
                    "example1": {
                        "Input": "3\n1\n5\n2\n1 3\n3\n3 2 1",
                        "Output": "0\n5\n8",
                        "Explanation": "Test case 1 1: Consider the following sequence of spells: Choose i = 1 i=1 and set A i =0 A i =0. The magician will now take 0 0 damage, and the process since every army has been destroyed. Test case 2 2: Consider the following sequence of spells: The magician will move to city 2 2, so K =2 K=2. The array remains A =[1,3] A=[1,3], so he will take 1 + 3 = 4 1+3=4 damage. Choose i =2 i=2 and set A 2 =0 A 2 =0. The array is now [1,0] [1,0], so he will take 1 + 0 = 1 1+0=1 damage. Choose i =1 i=1 and set A 1 =0 A 1 =0. The array is now [0,0] [0,0], so he will take 0 + 0 = 0 0+0=0 damage. All armies have been destroyed, so the process ends. The total damage taken is 4 + 1 = 5 4+1=5. It can be shown that this is the minimum possible."
                    }
                }
            ],
            "Constraints": [
                "1≤T≤10^3",
                "1≤N≤5000",
                "1≤Ai≤10^9",
                "The sum of N over all test cases won't exceed 5000."
            ],
            "Solution": "Consider some index i. A i will be added to the score once each time: The magician hasn’t yet reached index i, or The magician is moving beyond i, but hasn’t yet set A i to 0, or The magician sets some A j to 0, but hasn’t yet set A i to 0. The first one among these is trivial: the magician needs i−1 steps to reach index i for the first time. So, we add (i−1)⋅A i to the answer for every i. Now, we only need to worry about what happens once the magician is already at index i or beyond. We also make the following observation: whenever the magician chooses to set some A i to 0, it’s always optimal to choose the maximum existing one to do so (if there are multiple maximums, let’s break ties by choosing the leftmost among them). Let d p i denote the answer for the suffix starting from index i. To compute this, let’s try fixing k≥i to be the index where the magician sets A i=0. Then, A cost of (k−i)⋅A i is incurred by the movement. For every index j such that i<j≤k and A j>A i, it’s optimal to delete this index before we delete A i. So, each such index “delays” the deletion by one step. If there are x such indices, we incur an additional x⋅A i damage. x is easily maintained by just processing k in increasing order. For every other index (including those past k), A i will be deleted before them, so they will all get delayed instead. This incurs an additional cost of S, where S is the sum of values of all these indices. S is also easily maintained if k is processed in increasing order, with the additional help of suffix sums on array A. Let M be the minimum cost across all k≥i. We then simply have d p i=M+d p i+1. Note that the fact that we can take d p i+1 itself requires a proof of correctness - we’re essentially saying that the optimal deletion index we find for i will not conflict with the already existing optimal solution (note that when fixing k, we assumed that every delay was made optimally - as in the smaller value being delayed by a larger one). Proof Consider two indices i<j. Let A i≤A j, and their optimal deletion positions found via the given algorithm be r i and r j. We’ll prove that there’s no conflict between them - that is, either r i<j, or r i≥r j. Consider some index k between j and r j. When at index i, comparing the costs between choosing k and r j as the deletion index: Indices ≤k and >r j contribute the same cost to both, so they can be ignored. For k<x≤r j, we get a cost of A x when looking at k, and min(A x, A i) when looking at r j. In particular, if A x≤A i then the contribution to both is the same, so again we can ignore such indices. When looking at r j, we get an extra (r j−k)⋅A i from the movement costs. So, if there are m 1 indices between k+1 and r j containing values >A i, and the sum of values at these indices is s 1, our claim will be satisfied iff we can show that (r j−k+m 1 )⋅A i≤s 1. To that end, let’s perform the same analysis with indices k and r j, but for the index j this time. A similar argument tells us that we want to compare the quantities (k−x+m 2 )⋅A j and s 2, where: m 2 is the number of values at indices between k+1 and r j that are >A j. s 2 is the sum of the above values. Now, we already know r j is optimal for index j. This means (r j−k+m 2 )⋅A j≤s 2. Since A j≥A i, this tells us that (r j−k+m 2 )⋅A i≤s 2. From here, observe that we reach (r j−k+m 1 )⋅A i in the LHS by adding one copy of A i for each element that’s >A i but ≤A j. Meanwhile, in the RHS we reach s 1 from s 2 by adding the value of each element that’s >A i but ≤A j. So, an equal number of terms are added to both sides; but each element added to the LHS is smaller than each added to the RHS. This maintains the inequality, and so we obtain (r j−k+m 1 )⋅A i≤s 1 as desired. A similar proof can be made for the case when i<j and A i>A j. The end result is that the optimal deletion points found by our algorithm don’t conflict, as we wanted. TIME COMPLEXITY: O(N 2 ) per testcase.",
            "code": "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tsuf = a[:] + [0]\n\tdp = [0]*(n+1)\n\n\tfor i in reversed(range(n)):\n\t\tsuf[i] = suf[i+1] + a[i]\n\t\tmore, lesssm = 0, 0\n\t\tdp[i] = suf[i+1]\n\t\tfor k in range(i+1, n):\n\t\t\tif a[k] > a[i]: more += 1\n\t\t\telse: lesssm += a[k]\n\t\t\tdp[i] = min(dp[i], (k-i+more)*a[i] + lesssm + suf[k+1])\n\t\tdp[i] += dp[i+1]\n\tprint(dp[0] + sum(i*a[i] for i in range(n)))"
        }
    ]
}