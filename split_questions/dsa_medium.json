{
    "medium-question": [
        {
            "difficulty": "1789",
            "title": "Chef Loves Beautiful Strings (Easy Version)",
            "Description": "This is the easy version of the problem. Here, you only need to compute f(S) for the given binary string S. The beauty of a binary string T, denoted f(T), is defined as follows. Consider the following algorithm (T is 1-indexed). Let score=0. Repeat the following |T|−1 times: Choose an index i (1≤i≤|T|), delete T_i from the string, and concatenate the remaining parts together. Note that this reduces the length of T by 1. After the deletion, let K denote the number of indices i such that 1≤i<|T| and T_i≠T_{i+1}. Add K to score. The beauty of T is then defined to be the maximum possible value of score at the end of this algorithm. You are given a binary string S of length N. Find f(S). Input Format The first line of input will contain a single integer T, denoting the number of test cases. Each test case consists of two lines of input. The first line of each test case contains one integer N — the length of S. The next line contains the binary string S. Output Format For each test case, output on a new line f(S).",
            "Examples": [
                {
                    "example1": {
                        "Input": "4\n3\n001\n2\n11\n3\n010\n5\n11011",
                        "Output": "1\n0\n1\n5",
                        "Explanation": "Test case 1: Consider the following sequence: Choose i=1. After this T becomes 01 and K is equal to 1. Add K to score, to obtain score=1. Choose i=1. After this T becomes 1 and K is equal to 0. score remains 1. It can be shown that no matter the sequence of operations, attaining score>1 is not possible. Test case 2: As all the characters of S are the same, the maximum possible score after the algorithm will be 0. Test case 4: Consider the following sequence: Choose i=2. After this T becomes 1011 and K is equal to 2. Our score is 2. Choose i=4. After this T becomes 101 and K is equal to 2. Our score is 4. Choose i=3. After this T becomes 10 and K is equal to 1. Our score is 5. Choose i=2. After this T becomes 1 and K is equal to 0. Our score is 5. It can be shown that 5 is the maximum score we can reach."
                    }
                }
            ],
            "Constraints": [
                "1≤T≤10^5",
                "1≤N≤2⋅10^5",
                "S is a binary string, i.e, contains only the characters 0 and 1.",
                "The sum of N over all test cases won't exceed 2⋅10^5."
            ],
            "Solution": "Let k denote the number of adjacent different characters in S. For example, if S=110100 then k=3. Let’s analyze how k changes when one character is deleted from S. This requires a bit of casework. Casework If we delete S1, If S1=S2, k doesn’t change at all. Otherwise, k decreases by 1. Similarly, deleting SN reduces k by either 0 or 1, depending on whether SN=SN−1 or not. Next, say we delete Si for some index 1<i<|S| (that is, some character in the middle of S). If Si−1≠Si+1, k doesn’t change. If Si−1=Si+1, we again have two further cases: If Si=Si−1, k doesn’t change (this is, for example, deleting the middle element from 000). If Si≠Si−1, k reduces by 2 (this corresponds to deleting the middle element from 010). The important thing to note here is that no matter what, k cannot increase: it either remains the same, decreases by 1, or by 2. To compute f(S), we repeatedly delete a character from it, update k, and add k to the score. Our objective is to maximize this sum: and so ideally, we perform deletions that don’t change k as much as possible. This is, in fact, always possible! That is, we can always perform moves that don’t affect k, till we’re forced to do so - at which point every following move can reduce k by 1, till we eventually reach k=0 exactly when the string has length 1. Proof First, consider the case when S is an “alternating” string, i.e, S=010101… or S=101010… For such a string, we’ll have k=|S|−1. Deleting the first (or last) character of S will reduce both |S| and k by 1, which is the best we can do. If S is not an alternating string, S must satisfy at least one of the following: Every character of S is the same. In this case, k=0 already, and it doesn’t matter which character we delete. S contains 001 as a substring. Here, we can delete the middle 0, and k doesn’t change. S contains 110 as a substring. Here, we can delete the middle 1, and k doesn’t change. So, if every character of S is initially the same, the moves we make don’t matter (and k is always 0). Otherwise, we can always perform moves that don’t reduce k, till S becomes an alternating string. For an alternating string, k is one less than the length; so any move we make is forced to reduce k as well (since k can’t be ≥|S|). We have a way to always reduce k by exactly 1, and so that’s optimal. This gives us a rather simple way to calculate the cost. Let k initially be the number of adjacent different characters in S. Then, The last few moves will add k−1, k−2, k−3, …, 0 to our score. This adds 0+1+2+…+(k−1)=k⋅(k−1)/2 to the overall total. Every other move will add k to the score. That’s (N−1−k) moves, for a total of (N−1−k)⋅k. The final answer is thus simply (N−1−k)⋅k+k⋅(k−1)/2 TIME COMPLEXITY: O(N) per testcase.",
            "code": "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    k = 0\n    for i in range(n-1):\n        k += s[i] != s[i+1]\n    \n    print((n-1-k)*k + k*(k-1)//2)"
        },
        {
            "difficulty": "2002",
            "title": "Square String",
            "Description": "The sqing value for a binary string S of length N is calculated as follows: Let X=0 be the initial sqing value. For each i from 1 to N, let j be the largest index such that 1≤j<i and S[j]≠S[i]. If such an index j exists, add (i−j)² to X, otherwise do nothing. For example, consider S=000110. For i=1,2,3, there is no j<i such that S[j]≠S[i]. For i=4 and i=5, we find j=3, and add (4−3)²=1 and (5−3)²=4 to the answer, respectively. For i=6, we find j=5 and add (6−5)²=1 to the answer. The sqing value is thus 1+4+1=6. You are given N. There are 2^N binary strings of length N. Find the sum of all their sqing values. This sum can be large, so compute it modulo 10^9+7. As a reminder, a binary string is a string whose characters are all either 0 or 1. Input Format The first line of input will contain a single integer T, denoting the number of test cases. The first and only line of each test case contains a single integer N — the length of the binary strings to be considered. Output Format For each test case, output on a new line the answer, modulo 10^9+7.",
            "Examples": [
                {
                    "example1": {
                        "Input": "3\n2\n3\n838",
                        "Output": "2\n16\n839372959",
                        "Explanation": "Test case 1: The possible strings are {\"00\",\"01\",\"10\",\"11\"} {\"00\",\"01\",\"10\",\"11\"}. The sqing value for \"00\" \"00\" is 00. The sqing value for \"01\" \"01\" is 11 (for i=2, we find j=1). The sqing value for \"10\" \"10\" is 11 (for i=2, we find j=1). The sqing value for \"11\" \"11\" is 00. Hence, the answer to this test case is 22. Test case 2: There are 8 binary strings of length 3. The sqing value for \"000\" \"000\" is 00. The sqing value for \"001\" \"001\" is 11. The sqing value for \"010\" \"010\" is 22. The sqing value for \"011\" \"011\" is 55. The sqing value for \"100\" \"100\" is 55. The sqing value for \"101\" \"101\" is 22. The sqing value for \"110\" \"110\" is 11. The sqing value for \"111\" \"111\" is 00. Hence, the answer to this test case is 1616."
                    }
                }
            ],
            "Constraints": [
                "1≤T≤1000",
                "1≤N≤5⋅10^5",
                "The sum of N over all test cases won't exceed 5⋅10^5."
            ],
            "Solution": "For convenience of notation, let f(S) denote the sqing value of S. Observe that f(S) is the sum of squares of several values of (i−j). Further, (i−j) lies between 1 and N−1, since j<i. Let’s fix the value of (i−j), and see how many times (i−j)² appears in the summation of all f(S). Let k=i−j. Then, For this difference to be possible at all, i should be an index ≥k+1, since we need j≥1. This gives us N−k choices for what i is, which then uniquely fixes j. We want Si≠Sj, so there are two options: either Si=0 and Sj=1, or vice versa. By definition, j should be the closest index to i before it, that has a different value. That means, for every index k such that j<k<i, we are forced to fix Sk=Si. However, indices <j or >i have no such restrictions, and can be anything. There are N−(i−j+1) ‘free’ indices, each of which can take two values (0 or 1). Since k=i−j, we have N−k−1 free indices. Putting everything together, the number of times k appears as a difference in the computation of f(S) across all S, is 2⋅(N−k)⋅2^(N−k−1). Its contribution to the answer is thus this quantity, multiplied by k². To obtain the overall answer, just sum this up across all k, to obtain ∑_(k=1)^(N−1) 2⋅(N−k)⋅2^(N−k−1)⋅k². This is easily computed in O(N) or O(NlogN) time by just looping over k. TIME COMPLEXITY: O(N) per testcase.",
            "code": "mod = 10**9 + 7\nfor _ in range(int(input())):\n\tn = int(input())\n\tans = 0\n\tfor i in range(1, n):\n\t\tch = 2 * (n - i)\n\t\trem = n - i - 1\n\t\tch *= pow(2, rem, mod)\n\t\tans += ch * i * i % mod\n\tprint(ans % mod)"
        }
    ]
}